{"./":{"url":"./","title":"introduction","keywords":"","body":"UIFoundationNote - From GitBook 学习UI基础教程的MarkDown笔记 Wechat: siaoxiorliao Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-18 13:15:30 "},"1225/1225.html":{"url":"1225/1225.html","title":"1225 storyboard/控件连线/UIVIew","keywords":"","body":"1225 项目启动过程 main.m文件 找到AppDelegate 找到AppDelegate对应项目配置是主故事板 加载故事板中箭头指向的控制器 显示该控制器的view 在故事板中只有UIView才能作容器,其他不可以,但是可以在代码中使用其他作为容器 storyboard控件连线 控件只有继承自UIControl才能有连线事件,比如Label就没有 sender:拿到控件 经典错误: 错误一: this class is not key value coding-compliant for the key testLabel 原因:有多余的连线 解决:查看控件然后删除多余的连线 错误二: unrecognized selector sent to instance 0x7feb69418640 原因:找不到对应的方法 解决:1.添加对应的方法 2.删除多余的连线 拖入控制器至controller中只是addSubview didReceiveMeoryWarning方法是当程序发出内存警告后执行的方法,在这里可以相应地释放内存 控件继承关系 下面是继承自UIView UIView UIView常见的属性 UIView *superview 获得父控件 NSArray *subviews 获得子控件 NSInteger Tag 控件的id标识,父控件可以通过tag来找到子控件 CGAffineTransform transform 控件的形变属性(可以设置旋转角度,比例缩放,平移等属性) CGRect frame 控件矩形框在父控件中的位置和尺寸(父控件左上角为坐标原点) 想让frame里的值递增 不能通过直接 self.label.frame.size.width += 50;来递增(frame有getter,setter方法,但是里面的结构体是没有的)因为结构体是值传递的,所以先获取frame,再直接传frame就行了 CGRect frame = self.label.frame; frame.size.width += 50; self.label.frame = frame; CGRect bounds 控件矩形框的位置和尺寸(以自己左上角为坐标原点,bounds的x,y一般为0,所以bounds是用来改变尺寸的,iOS9以后,改变bounds,中心点不变,向四周延伸) CGPoint center 控件中点的位置(以父控件左上角为坐标原点) 控制器View的父控件是 UIWindow 执行viewDisAppear才能拿的到 在ViewDidLoad方法里面还不能拿到控制器view的superView(UIWindow),只有在viewDidAppear里才有(移除控制器view只有在viewDidAppear方法里才有效果) UIView常见的方法 (void)addSubview:(UIView *)view;//1. 添加一个子控件view (void)removeFromSuperview; //2. 将自己从父控件中移除(自己调用) (UIView * )viewWithTag:(NSInteger)tag;//3. 根据子控件的tag拿到相应的子控件(父控件调用)注意点! viewWithTag方法只能拿到有对应关系的控件,比如View里包含3个控件,那么可以拿3个,把button放进label里面是包含不进去的,所以拿不到button //尽量少使用tag.效率差(通常都是递归遍历子控件,查看控件的tag,找到tag然后返回),容易乱: tag应用场景:1225-18-34不需要连线定义,只通过tag,switch判断即可 Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-18 22:15:56 "},"1226/1226.html":{"url":"1226/1226.html","title":"1226 UILabel/换行/文本框大小随变","keywords":"","body":"1226 UILabel/换行/文本框大小随变 UILabel UILabel常见属性 NSString *text 显示的文字 UIFont *font 字体 可设置 文字大小或粗体或斜体 UIColor *textColor 文字的颜色 NSTextAlignment textAlignment 对齐模式(左右居中) NSInteger numberOfLines 文字行数 NSLineBreakMode lineBreakMode 换行模式 clip:直接裁剪 character Wrap : 根据字节换行(需设置自动换行) word Wrap: 根据单词换行(默认,需设置自动换行) Truncate Head: 开头省略 Truncate Middle: 中间省略 Truncate tail: 结尾省略 换行的情况 : numberOfLines = 0 -> 自动换行 如果文字过多,撑开了文本框,还是会出现... numberOflines > 0 ->设置行数 文字会在遇到文本框边缘即会换行,如果文本框太小或者行数太小,也会出现... 设置文本框大小随文字改变 + numberOfLines = 0 这种方法不会出现... ↓ //等待代码 //lab.numberOfLines = 0; //lab.textAlignment = NSTextAlignmentCenter; //lab.backgroundColor = [UIColor redColor]; //lab.shadowOffset = CGSizeMake(100, 200); Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-18 21:51:24 "},"1226/haha.html":{"url":"1226/haha.html","title":"-UIImageView/frame/毛玻璃","keywords":"","body":" UIImageView UIImageView常见属性 UIImageView UIImageView常见属性 UIImage *image 显示的图片 NSArray *animationImages 显示的动画图片 NSInteger animationRepeatCount 动画播放次数(默认0是无限播放) NSTimeInterval animationDuration 一次动画时长 Bool clipsToBounds 是否裁剪多余的部分 UIViewContentMode contentMode 毛玻璃效果 UIToolbar *toolb = [[UIToolbar alloc]init]; toolb.frame = imageV.bounds; //toolb.frame = imageV.frame; toolb.barStyle = UIBarStyleDefault; toolb.alpha = 0.9;你好ha a [imageV addSubview:toolb]; [self.view addSubview:imageV]; 为什么toolb.frame = imageV.bounds而不是frame? : 因为 imageV.frame可能会变,但是imageV.bound是不会变的(x,y永远是0,玻璃效果全覆盖,宽高也不变,这就保证了永远全覆盖在图片上了) 设置UIImageView的frame方式 //1. imageView.frame = CGRectMake(100,100,267,400); //2. imageView.frame = (CGRect){{100,100},{267,400}}; //3. UIImage *image = [[UIImage alloc]init]; imageView.frame = CGRenctMake(100,100,image.size.width,image.size.height); imageView.image = image; //4.(常用) UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGMake(100,100,267,400)]; imageView.image = image; //5 UIImageView *imageView = [[UIImageView alloc]initWithImage:@\"1\")];(默认有尺寸,尺寸就是图片的尺寸) ImageView.center = CGPointMake (self.view.frame.size.width * 0.5,self.view.size.height * 0.5);//(位置) Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-19 11:12:35 "},"1226/he-he.html":{"url":"1226/he-he.html","title":"-资源存放选项说明和文件加载(重要)","keywords":"","body":" 资源存放问题(重点) 拖入文件的选项说明(重要) 拖入文件的方式说明(重要) 加载图片的方式: 加载文件的两种方式选择 资源存放问题(重点) 1226-10-6 开发阶段:源代码+资源+类库 测试阶段:打包->ipa 上架: ipa+描述信息->发布到AppStore 拖入文件的选项说明(重要) 1226-10-15 1.copy items if needed 拷贝一份到项目中,存在于项目的目录 2.Create groups 创建组,虚拟的文件结构,里面的文件可被编译(删除的时候不会删除文件夹); 3.Create folder references 创建引用,有真实的文件结构,里面的文件不会被编译; 4.加入ipa包中(如果是组,不带结构创建进ipa包,反之) 拖入文件的方式说明(重要) 放入assets的 可以通过imageName:@\"1\"访问 不可以通过imageWithContentsOfFile(路径)访问,因为在ipa包中是在assets.car中的(取不到路径,而imageName是有xcode自己的方式) copy,通过组创建,加入ipa包中 两种都可以拿到 不copy,通过组创建,加入ipa包中(copy问题) 两种都可以拿到 改变文件夹名字,编译报错 copy,通过组创建,不加入ipa包中(ipa包问题) 两种都拿不到 copy,通过folder创建,加入ipa包中(访问方式问题) 可以通过imageName访问,但要加入路劲(/测试/测试/这里.png) 不可以通过imageWithContentsOfFile访问 加载图片的方式: imageNamed: imageWithContentsOfFile: 加载Assets.xcassets这里面的图片: 1> 打包后变成Assets.car 2> 拿不到路径 3> 只能通过imageNamed:来加载图片 4> 不能通过imageWithContentsOfFile:来加载图片 放到项目中的图片: 1> 可以拿到路径 2> 能通过imageNamed:来加载图片 3> 也能通过imageWithContentsOfFile:来加载图片 加载文件的两种方式选择 方式1.imaeNamed: 既可以访问assets中的,也可以访问ipa包中的 方式2.只能访问ipa; 图片的两种加载方式: 1> imageNamed: a. 就算指向它的指针被销毁,该资源也不会被从内存中干掉 b. 放到Assets.xcassets的图片,默认就有缓存 c. 图片经常被使用 2> imageWithContentsOfFile: a. 指向它的指针被销毁,该资源会被从内存中干掉 b. 放到项目中的图片就不会有缓存 c. 不经常用,大批量的图片 下面主要是说一下他们的区别(重要): imageNamed: 用这个方法加载图片分为两种情况: 系统缓存有这个图片: 直接从缓存中取得(放入assets中运行一开始默认就有缓存) 系统缓存没有这个图片 : 通过传入的文件名对整个工程进行遍历 (在application bundle的顶层文件夹寻找名字的图象 ), 如果如果找到对应的图片 , iOS 系统首先要做的是将这个图片放到系统缓存中去,以备下次使用的时候直接从系统缓存中取 , 接下来重复第一步,即直接从缓存中取 那么试想一下 , 如果要加载的这个图片的文件量很多,文件大小很大,内存不足,内存泄露,甚至是程序的崩溃都是很容易发生的事. imageWithContentsOfFile: 用这个方法只有一种情况,那就是仅仅加载图片 , 图像数据不会被缓存 . 因此在加载较大图片的时候 , 以及图片使用情况很少的时候可以使用这两个方法 , 降低内存消耗. Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-19 11:20:17 "},"1226/quanhuang.html":{"url":"1226/quanhuang.html","title":"-拳皇图片动画实例/音效","keywords":"","body":"拳皇动画实例 初始化,如果在点击执行后才加载图片,那其他地方要用的时候就也要加载图片,所以把加载图片的过程放在viewDidLoad里面,再用全局变量接收,只要加载一次图片,就可以在任何地方使用图片了. 代码抽取:重复代码过多,代码之间区别很小,只有一点不同的地方,这时可以抽取代码,将不同的地方作为参数即可. 大小招动画执行完后需要站立,但是直接用站立则覆盖了大小招动画,所以可以加入一个延迟方法,在点击按钮后先加载3秒大小招,延迟3秒执行站立的动画,就可以达到效果[self performSelector:@selector(stand) withObject:nil afterDelay;self.imageView.animationDuration]; //:@selector(stand) = NSSelectorFromString(stand) 方法 //: 间隔时间 内存优化:图片加载完后内存大,不玩了,就游戏结束,释放内存 (1) 释放数组self.standImages = nil; self.smaillImages = nil; self.bigImages = nil; 游戏结束后还是在站立(有站立的缓存) 加入 self.imageView.animationImages = nil;清除缓存即可播放音效 #import self.bgImageView.frame = self.view.bounds;//设置大小 UIToolbar *tb = [[UIToolbar alloc]init];//毛玻璃凶过 tb.frame = self.bgImageView.bounds; tb.barStyle = UIBarStyleBlack; tb.alpha = 0.95; [self.bgImageView addSubview:tb]; NSString *path = [[NSBundle mainBundle] pathForResource:@\"mySong2.mp3\" ofType:nil];//取资源路径 NSURL *url = [NSURL fileURLWithPath:path];//路径转url AVPlayerItem *playItem = [[AVPlayerItem alloc]initWithURL:url];//创建歌曲 self.player = [[AVPlayer alloc]initWithPlayerItem:playItem];//创建 并 接收avplayer Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-18 20:30:50 "},"1226/yanse.html":{"url":"1226/yanse.html","title":"-开发常用的颜色","keywords":"","body":"开发中常用的颜色 32位颜色组成: 32位颜色格式: 24位是去掉alpha而已 12位颜色: 每个颜色占4bit 每个颜色通道取值为0-2的4次方-1即15 PNG无损 JPG无损(压缩了alpha通道) 开发: 纯色用12位 要用到alpha则24或32位 Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-18 22:14:58 "},"shortcutkey/shortcutkey.html":{"url":"shortcutkey/shortcutkey.html","title":"shortcutKey 快捷键集合","keywords":"","body":"Xcode快捷键 command + ← 左缩进command + → 右缩进command + ↑ 跳转上部command + ↓ 跳转下部control + command + ↑ 切换.h和.m文件 command + F 搜索内容command + shift +F 搜索包含内容的文件 command + option + enter 双编辑器模式 command + enter 单编辑器模式 command + option ← 折叠代码control + 6 搜索方法option + 单击文件 将文件放入副编辑器 单击文件 将文件放入主编辑器command + / 注释command + N 在当前目录新建文件command + shift + N 新建项目command + shift + k clean工程command + shift + 0 打开文档参考 storyboard场景快捷键 option + 滚轮 双击 放大缩小 模拟器快捷键 command + shift + H 回到主界面 command + s 截图command + 12345 切换模拟器窗口大小command + L 锁屏option 开启双手势command + ← 切换模拟器方向command + control + Z 模拟器抖动 command + K 使用系统键盘或系统和模拟器键盘同时使用command + shift + K 只使用模拟器键盘 Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-18 13:15:30 "},"gitbooklearning.html":{"url":"gitbooklearning.html","title":"gitbooklearning","keywords":"","body":"gitBook Editor gitbook Editor的bug太多了,这里给一些建议 Editor是gitbook出的编辑器,可以支持上传到gitHub和gitBook端,想要同步到gitHub就在gitHub新建依赖然后在gitBook上新建gitHub类型的书,gitHub上首页默认显示README.md内容. 进入官网下载安装 book分为本地和云端,云端即是你在GitBook上的书,本地就是在本地新建的 当你更新书的时候,gitBook上会updating,如果update失败,一般是编辑的内容有误,根据错误内容的行数你更改内容就可以再次上传成功 使用注意 b 好难用的坑 b# 你好啊 b好难用 b 好难用 b很好用吗 进行增删改最好在Editor中进行,不能再目录中进行,Editor会自动检测改变状况 每次要增加删除文件记住要先save(保存到本地)和push(上传到gitHub和gitBook),不然会回倒,让人摸不着头脑. 刚开始的文件名必须是英文(可以先新建英文文件再改成中文目录) 使用时最好先制定好目录,比如我就把每个章节的图片,md等放在那个章节的文件夹里 要使用多级目录可以编辑SUMMARY.md文件,详情参考我的SUMMARY.md文件 重点 可以使用book.json自定义书的风格,比如去掉分享按钮,更改搜索方式,目录可以收缩等等 安装插件 使用网上格式(具体网上很多),注意仔细检查内容 下面是我遇到的坑,很恐怖 book.json存放在最上层目录中也就是book的第一层 当你需要重新安装或者删除插件时,你要先把你生成的本地化的书删除,才能重新安装 #一个超级巨大的坑: \"这个符号一定要对.... Copyright © siaoxiorliao 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-07-19 11:11:59 "}}