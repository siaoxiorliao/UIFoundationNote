# 1226

# UILabel
### UILabel常见属性
* NSString \*text 显示的文字
* UIFont \*font 字体
> 可设置 文字大小或粗体或斜体
* UIColor *textColor 文字的颜色
* NSTextAlignment textAlignment 对齐模式(左右居中)
* NSInteger numberOfLines 文字行数
* NSLineBreakMode lineBreakMode 换行模式
> clip:直接裁剪
character Wrap : 根据字节换行(需设置自动换行)
word Wrap: 根据单词换行(默认,需设置自动换行)
Truncate Head: 开头省略
Truncate Middle: 中间省略
Truncate tail: 结尾省略

##### 换行的情况 :
* numberOfLines = 0 -> 自动换行
> 如果文字过多,撑开了文本框,还是会出现...
* numberOflines > 0 ->设置行数
> 文字会在遇到文本框边缘即会换行,如果文本框太小或者行数太小,也会出现...
* 设置文本框大小随文字改变 + numberOfLines = 0
> 这种方法不会出现...  ↓

```objectivec
//等待代码
    //lab.numberOfLines = 0;
    //lab.textAlignment = NSTextAlignmentCenter;
    //lab.backgroundColor = [UIColor redColor];
    //lab.shadowOffset = CGSizeMake(100, 200);
```

# UIImageView
### UIImageView常见属性
* UIImage *image 显示的图片
* NSArray *animationImages 显示的动画图片
* NSInteger animationRepeatCount 动画播放次数(默认0是无限播放)
* NSTimeInterval animationDuration 一次动画时长


* UIViewContentMode contentMode
![](/assets/96A67D4A-10A8-491A-A02C-DD82441E5B18.png)

##### 毛玻璃效果
```objectivec
    UIToolbar *toolb = [[UIToolbar alloc]init];
    toolb.frame = imageV.bounds;
    //toolb.frame = imageV.frame;
    toolb.barStyle = UIBarStyleDefault;
    toolb.alpha = 0.9;
    [imageV addSubview:toolb];
    [self.view addSubview:imageV];
```
> 为什么toolb.frame = imageV.bounds而不是frame? :
> 因为 imageV.frame可能会变,但是imageV.bound是不会变的(x,y永远是0,玻璃效果全覆盖,宽高也不变,这就保证了永远全覆盖在图片上了)

##### 设置UIImageView的frame方式
 1. imageView.frame = CGRectMake(100,100,267,400);
 2. imageView.frame = (CGRect){{100,100},{267,400}};
 3. UIImage *image = [[UIImage alloc]init];<br/>
 imageView.frame = CGRenctMake(100,100,image.size.width,image.size.height);</br>
 imageView.image = image;
 4. (常用)UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGMake(100,100,267,400)];</br>
 imageView.image = image;
 5. UIImageView *imageView = [[UIImageView alloc]initWithImage:@"1")];(默认有尺寸,尺寸就是图片的尺寸)</br>
 ImageView.center = CGPointMake</br>
(self.view.frame.size.width * 0.5,self.view.size.height * 0.5);(位置)


## 资源存放问题(**重点**)
1226-10-6
开发阶段:源代码+资源+类库
测试阶段:打包->ipa
上架: ipa+描述信息->发布到AppStore

## 拖入文件的方式说明
![](/assets/WX20170717-202950.png)
> * copy items if needed 拷贝一份

> * **第一种** Create groups 
>> * 创建组,创建虚拟文件夹(自己手动创建的组(黄色文件夹)的文件实际上不会被创建进项目中,但从外部引入的则会进入项目中)
>> * 在目录形成文件夹(↓下面的图片)
>> * 创建的是黄色文件夹,这文件是会被编译的,
>> * 在ipa包中是这样
![](/assets/WX20170717-220327.png)
>> * 当删除的时候,还是会保留文件夹,但里面的文件没了
>> * 使用的时候是这样#include xxx.h
>> * **最好用这种**

> * **第二种** Create folder references
>> * 创建引用,
>> * 在目录形成文件夹 (↓下面的图片)
>> * 在ipa包中是这样
![](/assets/WX20170717-220011.png)
>> * 这些文件不会被编译,创建的是蓝色文件,
>> * 当删除的时候,不会保留文件夹
>> * 使用的时候则是这样 #include myScripts/xxx.h
![](/assets/WX20170717-214646.png)

> * **第三种** assets
>> * 在assets中也是黄色文件夹
>> * 在目录是存放在assets文件夹中
>> * 在ipa包中则是放在asset.car中
>> * 删除不会保留文件夹

## 加载文件的两种方式
![](/assets/WX20170717-200057.png)
后退进入bundle中,选择项目的文件显示包内容进入ipa包
![](/assets/WX20170717-200218.png)
如果是将文件放入assets.xcassets中的话,文件是在Assets.car中,(拿不到路径,只能通过imageNamed访问)
可以将他放入项目中,这时就可以在ipa包中看到它们了,可通过访问ipa包(路径)拿文件</br>
![](/assets/WX20170717-200631.png)

* 方式1.imaeNamed: 既可以访问assets中的,也可以访问ipa包中的
* 方式2.只能访问ipa; **好处1226-14-13:** ↓↓↓↓↓↓

![](/assets/WX20170717-201301.png)
>    图片的两种加载方式:
    1> imageNamed:
      a. 就算指向它的指针被销毁,该资源也不会被从内存中干掉
      b. 放到Assets.xcassets的图片,默认就有缓存
      c. 图片经常被使用
 
>    2> imageWithContentsOfFile:
      a. 指向它的指针被销毁,该资源会被从内存中干掉
      b. 放到项目中的图片就不会有缓存
      c. 不经常用,大批量的图片

### 拳皇动画实例
1. 初始化,如果在点击执行后才加载图片,那其他地方要用的时候就也要加载图片,所以把加载图片的过程放在viewDidLoad里面,再用全局变量接收,只要加载一次图片,就可以在任何地方使用图片了.
2. 代码抽取:重复代码过多,代码之间区别很小,只有一点不同的地方,这时可以抽取代码,将不同的地方作为参数即可.
3. 大小招动画执行完后需要站立,但是直接用站立则覆盖了大小招动画,所以可以加入一个延迟方法,在点击按钮后先加载3秒大小招,延迟3秒执行站立的动画,就可以达到效果
```objectivec
[self performSelector:@selector(stand) withObject:nil afterDelay;self.imageView.animationDuration];
//<#(nonnull SEL)#>:@selector(stand) = NSSelectorFromString(stand)
//<#(NSTimeInterval)#>: 间隔时间
4. 内存优化:图片加载完后内存大,不玩了,就游戏结束,释放内存
 (1) 释放数组
 self.standImages = nil;
 self.standImages = nil;
 self.standImages = nil;
```
游戏结束后还是在站立(有站立的缓存)
加入 self.imageView.animationImages = nil;即可

##### 加入声音






 





