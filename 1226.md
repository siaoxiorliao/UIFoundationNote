# 1226

# UILabel
### UILabel常见属性
* NSString \*text 显示的文字
* UIFont \*font 字体
> 可设置 文字大小或粗体或斜体
* UIColor *textColor 文字的颜色
* NSTextAlignment textAlignment 对齐模式(左右居中)
* NSInteger numberOfLines 文字行数
* NSLineBreakMode lineBreakMode 换行模式
> clip:直接裁剪
character Wrap : 根据字节换行(需设置自动换行)
word Wrap: 根据单词换行(默认,需设置自动换行)
Truncate Head: 开头省略
Truncate Middle: 中间省略
Truncate tail: 结尾省略

##### 换行的情况 :
* numberOfLines = 0 -> 自动换行
> 如果文字过多,撑开了文本框,还是会出现...
* numberOflines > 0 ->设置行数
> 文字会在遇到文本框边缘即会换行,如果文本框太小或者行数太小,也会出现...
* 设置文本框大小随文字改变 + numberOfLines = 0
> 这种方法不会出现...  ↓

```objectivec
//等待代码
    //lab.numberOfLines = 0;
    //lab.textAlignment = NSTextAlignmentCenter;
    //lab.backgroundColor = [UIColor redColor];
    //lab.shadowOffset = CGSizeMake(100, 200);
```

# UIImageView
### UIImageView常见属性
* UIImage *image 显示的图片
* NSArray *animationImages 显示的动画图片
* NSInteger animationRepeatCount 动画播放次数(默认0是无限播放)
* NSTimeInterval animationDuration 一次动画时长
* Bool clipsToBounds 是否裁剪多余的部分

* UIViewContentMode contentMode
![](/assets/96A67D4A-10A8-491A-A02C-DD82441E5B18.png)

##### 毛玻璃效果
```objectivec
    UIToolbar *toolb = [[UIToolbar alloc]init];
    toolb.frame = imageV.bounds;
    //toolb.frame = imageV.frame;
    toolb.barStyle = UIBarStyleDefault;
    toolb.alpha = 0.9;你好ha a
    [imageV addSubview:toolb];
    [self.view addSubview:imageV];
```

> 为什么toolb.frame = imageV.bounds而不是frame? :
> 因为 imageV.frame可能会变,但是imageV.bound是不会变的(x,y永远是0,玻璃效果全覆盖,宽高也不变,这就保证了永远全覆盖在图片上了)

##### 设置UIImageView的frame方式
```objectivec
//1.
imageView.frame = CGRectMake(100,100,267,400);
//2.
imageView.frame = (CGRect){{100,100},{267,400}};
//3.
UIImage *image = [[UIImage alloc]init];
imageView.frame = CGRenctMake(100,100,image.size.width,image.size.height);
imageView.image = image;
//4.(常用)
UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGMake(100,100,267,400)];
 imageView.image = image;
 //5
UIImageView *imageView = [[UIImageView alloc]initWithImage:@"1")];(默认有尺寸,尺寸就是图片的尺寸)
 ImageView.center = CGPointMake
(self.view.frame.size.width * 0.5,self.view.size.height * 0.5);//(位置)
```


## 资源存放问题(**重点**)
1226-10-6
开发阶段:源代码+资源+类库
测试阶段:打包->ipa
上架: ipa+描述信息->发布到AppStore

## 拖入文件的选项说明(重要)
**1226-10-15**
![](/assets/WX20170717-202950.png)
> * 1.copy items if needed 
拷贝一份到项目中,存在于项目的目录
> * 2.Create groups 
创建组,虚拟的文件结构,里面的文件可被编译(删除的时候不会删除文件夹);
> * 3.Create folder references
创建引用,有真实的文件结构,里面的文件不会被编译;
> * 4.加入ipa包中(如果是组,不带结构创建进ipa包,反之)

![](/assets/WX20170717-200057.png)

![](/assets/WX20170717-200218.png)


## 拖入文件的方式说明(重要)

1. 放入assets的
> 可以通过imageName:@"1"访问
> 不可以通过imageWithContentsOfFile(路径)访问,因为在ipa包中是在assets.car中的(取不到路径,而imageName是有xcode自己的方式)

2. copy,通过组创建,加入ipa包中
> 两种都可以拿到

3. 不copy,通过组创建,加入ipa包中(copy问题)
> 两种都可以拿到
> 改变文件夹名字,编译报错

4. copy,通过组创建,不加入ipa包中(ipa包问题)
> 两种都拿不到

5. copy,通过folder创建,加入ipa包中(访问方式问题)
> 可以通过imageName访问,但要加入路劲(/测试/测试/这里.png)
> 不可以通过imageWithContentsOfFile访问

## 加载图片的方式:
   1. imageNamed:
   2. imageWithContentsOfFile:
   
   
   1. 加载Assets.xcassets这里面的图片:
    1> 打包后变成Assets.car
    2> 拿不到路径
    3> 只能通过imageNamed:来加载图片
    4> 不能通过imageWithContentsOfFile:来加载图片
 
   2. 放到项目中的图片:
    1> 可以拿到路径
    2> 能通过imageNamed:来加载图片
    3> 也能通过imageWithContentsOfFile:来加载图片
    

## 加载文件的两种方式选择

![](/assets/WX20170717-200218.png)

* 方式1.imaeNamed: 既可以访问assets中的,也可以访问ipa包中的
* 方式2.只能访问ipa;
![](/assets/WX20170717-201301.png)

>    图片的两种加载方式:
    1> imageNamed:
      a. 就算指向它的指针被销毁,该资源也不会被从内存中干掉
      b. 放到Assets.xcassets的图片,默认就有缓存
      c. 图片经常被使用
 
>    2> imageWithContentsOfFile:
      a. 指向它的指针被销毁,该资源会被从内存中干掉
      b. 放到项目中的图片就不会有缓存
      c. 不经常用,大批量的图片
      
**下面主要是说一下他们的区别(重要):**

* imageNamed: 

用这个方法加载图片分为两种情况:

> 系统缓存有这个图片: 直接从缓存中取得(放入assets中运行一开始默认就有缓存)

> 系统缓存没有这个图片 :
通过传入的文件名对整个工程进行遍历 (在application bundle的顶层文件夹寻找名字的图象 ), 如果如果找到对应的图片 , iOS 系统首先要做的是将这个图片放到系统缓存中去,以备下次使用的时候直接从系统缓存中取 , 接下来重复第一步,即直接从缓存中取

> 那么试想一下 , 如果要加载的这个图片的文件量很多,文件大小很大,内存不足,内存泄露,甚至是程序的崩溃都是很容易发生的事.

* imageWithContentsOfFile:

>用这个方法只有一种情况,那就是仅仅加载图片 , 图像数据不会被缓存 . 因此在加载较大图片的时候 , 以及图片使用情况很少的时候可以使用这两个方法 , 降低内存消耗.

### 拳皇动画实例
1. 初始化,如果在点击执行后才加载图片,那其他地方要用的时候就也要加载图片,所以把加载图片的过程放在viewDidLoad里面,再用全局变量接收,只要加载一次图片,就可以在任何地方使用图片了.
2. 代码抽取:重复代码过多,代码之间区别很小,只有一点不同的地方,这时可以抽取代码,将不同的地方作为参数即可.
3. 大小招动画执行完后需要站立,但是直接用站立则覆盖了大小招动画,所以可以加入一个延迟方法,在点击按钮后先加载3秒大小招,延迟3秒执行站立的动画,就可以达到效果
```objectivec
[self performSelector:@selector(stand) withObject:nil afterDelay;self.imageView.animationDuration];
//<#(nonnull SEL)#>:@selector(stand) = NSSelectorFromString(stand) 方法
//<#(NSTimeInterval)#>: 间隔时间
```
4. 内存优化:图片加载完后内存大,不玩了,就游戏结束,释放内存
 (1) 释放数组
 ```objectivec
 self.standImages = nil;
 self.smaillImages = nil;
 self.bigImages = nil;
```
游戏结束后还是在站立(有站立的缓存)
加入 self.imageView.animationImages = nil;清除缓存即可
##### 播放音效

```objectivec
    #import <AVFoundation/AVFoundation.h>
    self.bgImageView.frame = self.view.bounds;//设置大小
    UIToolbar *tb = [[UIToolbar alloc]init];//毛玻璃凶过
    tb.frame = self.bgImageView.bounds;
    tb.barStyle = UIBarStyleBlack;
    tb.alpha = 0.95;
    [self.bgImageView addSubview:tb];
    NSString *path = [[NSBundle mainBundle] pathForResource:@"mySong2.mp3" ofType:nil];//取资源路径
    NSURL *url = [NSURL fileURLWithPath:path];//路径转url
    AVPlayerItem *playItem = [[AVPlayerItem alloc]initWithURL:url];//创建歌曲
    self.player = [[AVPlayer alloc]initWithPlayerItem:playItem];//创建 并 接收avplayer
    
```






 





