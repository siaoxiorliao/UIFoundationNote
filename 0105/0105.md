# 0105
# 屏幕适配史
-> 写固定值(只有3.5inch (320 480))
-> autoresizingMask(5-5s (320 568))
为什么不用autolayout?因为要适配iOS5)
-> autolayout (iphone6宽度也发生变化,不用适配iOS5)相对于屏幕适配多样性来说autoresizingMask已经过时了
-> sizeclasses
# autoresizingMask使用
* 学习比较简单,学了后学autolayout也容易
* autoresizingMask和autolayout互不兼容
```objectivec
view.translatesAutoresizingMaskIntoConstraints = NO;
```
* autolayout和sizeclasses有关联

* 在size inspector中方向是反的
* autoresizingMask = 

    UIViewAutoresizingFlexibleLeftMargin 距离父控件的左边是可以伸缩的
UIViewAutoresizingFlexibleBottomMargin 距离父控件的底部是可以伸缩的
UIViewAutoresizingFlexibleRightMargin 距离父控件的右边是可以伸缩的
UIViewAutoresizingFlexibleTopMargin 距离父控件的顶部是可以伸缩的
UIViewAutoresizingFlexibleHeight  高度会跟随父控件的高度进行伸缩
UIViewAutoresizingFlexibleWidth  宽度会跟随父控件的宽度进行伸缩

```objectivec
layoutSubviews:

    // 设置contentSize
    self.scrollView.contentSize = CGSizeMake(self.scrollView.subviews.count * scrollViewW, 0);
    //在这里重新设置contentsize不影响滚动
    
nextPage:

    //滚动到下一页
    [self.scrollView setContentOffset:CGPointMake(page * self.scrollView.frame.size.width, 0) animated:YES];
```

# autolayout
* autoriszingMask只能解决与父控件的相对关系,不能解决与其他控件的关系

* autolayout能解决任何控件之间的相对约束关系

* Autolayout自iOS 6开始引入，由于Xcode 4的不给力，当时并没有得到很大推广自iOS 7（Xcode 5 iphone6）开始，Autolayout的开发效率得到很大的提升

* 苹果官方也推荐开发者尽量使用Autolayout来布局UI界面
* Autolayout能很轻松地解决屏幕适配的问题

## autolayout核心计算公式
**obj1.property1 =（obj2.property2 * multiplier）+ constant value**

## autoulayout在UILabel中
* UILabel高度随文字多少而改变,在cell中则不被允许.
* 可以设置父控件高度不一定,UILabel左边,上边,下边距离父控件一定,从而text变多时可以撑开父控件.
* 在之前父控件是可以被撑开的,而且在sb中可以看到,但是现在只有在模拟器上才可以看到,sb中看不到了.



